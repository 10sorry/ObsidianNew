
# Интелектуальные указатели

Дата: [[2025-07-23]]
Теги: #cpp
Связи: [[c++]] 

---
**Описание**:
### ❌ **1. Отсутствие информации о семантике указателя**

- Объявление `T* ptr` не говорит:
    
    - Указывает ли он на один объект или на массив.
        
    - Является ли он владельцем объекта или просто наблюдателем.
        

### ❌ **2. Неизвестно, кто отвечает за уничтожение**

- Из объявления нельзя понять:
    
    - Кто должен удалить объект.
        
    - Когда и как это должно быть сделано.
        

### ❌ **3. Неизвестен способ уничтожения**

- Даже если понятно, что объект нужно удалить, **неясно чем**:
    
    - `delete`?
        
    - `delete[]`?
        
    - Специальная функция `destroy(ptr)`?
        

### ❌ **4. Легко ошибиться с `delete` vs `delete[]`**

- Применение неправильного вида удаления ведёт к **неопределённому поведению**.
    

### ❌ **5. Трудности с гарантированным уничтожением**

- Обеспечить **точно одно уничтожение** объекта:
    
    - Сложно особенно при наличии **исключений**, **ветвлений**, **множественного доступа**.
        
    - Один лишний `delete` → UB, один пропущенный → утечка.
        

### ❌ **6. Опасность висячих указателей**

- После удаления объекта указатель может **по-прежнему ссылаться на освобождённую память**.
    
- Это ведёт к ошибкам, которые трудно отловить и отлаживать.

В `C++11` имеются *4* типа интелектуальных указателей:
- `unique_ptr`
- `shared_ptr`
- `auto_ptr`(устарел)
- `weak_ptr`

#### `unique_ptr` 

##### Что это?

- **Умный указатель**, управляющий **уникальным владением** ресурса (обычно динамически выделенного объекта).
    
- Автоматически вызывает `delete` или `delete[]` при уничтожении.
    
- Нельзя копировать — только **перемещать**!
    
---
#### Ключевые свойства

|Свойство|Описание|
|---|---|
|Владение|Только один `unique_ptr` владеет объектом|
|Копирование|**Запрещено** (`copy ctor` и `copy assign` удалены)|
|Перемещение|**Разрешено и обязательно** (`move ctor` и `move assign`)|
|Уничтожение|Автоматический вызов `delete` или `delete[]` при выходе из области видимости|
|Массивы|Поддерживается с помощью специализации `unique_ptr<T[]>`|
#### Конструкторы и операторы

```cpp
std::unique_ptr<T> ptr1 = std::make_unique<T>(args); // создание

std::unique_ptr<T> ptr2 = std::move(ptr1);           // перемещение владения

// std::unique_ptr<T> ptr3 = ptr2;                    // ❌ ошибка: копирование запрещено
```

---
#### Почему нельзя копировать?

- Если бы копировать разрешалось, два `unique_ptr` указывали бы на один ресурс → двойное удаление → UB.
    
---
#### Что происходит при перемещении?

```
unique_ptr(unique_ptr&& other) noexcept {
    ptr = other.ptr;
    other.ptr = nullptr; // "обнуляем" исходный указатель
}
```

- **Передаём владение** ресурса.
    
- Старый `unique_ptr` становится пустым (`nullptr`).
    
- Нет глубокого копирования данных, только перенос "сырых" указателей.
    
---
#### Особенности с массивами

- Для массивов используется `unique_ptr<T[]>`:
    
    - Вызывает `delete[]` автоматически.
        
    - Можно обращаться через оператор `[]`:
        
```
std::unique_ptr<int[]> arr = std::make_unique<int[]>(10);
arr[0] = 42;
```
---
#### Важные методы

|                |                                                |
| -------------- | ---------------------------------------------- |
| Метод          | Описание                                       |
| `release()`    | Отдаёт сырой указатель, обнуляя владение       |
| `reset()`      | Удаляет текущий объект, устанавливает nullptr  |
| `get()`        | Возвращает сырой указатель без потери владения |
| `operator*()`  | Доступ к объекту                               |
| `operator->()` | Доступ к членам объекта                        |

---
#### Пример базового использования

```cpp
#include <memory>

struct Foo { int x; };

int main() {
    auto p = std::make_unique<Foo>(); // создаём
    p->x = 42;

    std::unique_ptr<Foo> p2 = std::move(p); // перенос владения
    // p теперь пустой (nullptr)

    if (!p) {
        // ...
    }
}
```

---
#### `shared_ptr`

#### Что это?

- Умный указатель для **разделяемого владения** ресурса.
    
- Несколько `shared_ptr` могут указывать на один объект.
    
- Объект удаляется, когда последний `shared_ptr` перестаёт владеть (счётчик ссылок достигает нуля).
    
---
#### Ключевые свойства

|Свойство|Описание|
|---|---|
|Владение|Разделяемое, несколько владельцев|
|Копирование|Разрешено, увеличивает счётчик ссылок|
|Перемещение|Разрешено|
|Уничтожение|Объект удаляется при уничтожении последнего владельца|
|Счётчик ссылок|Встроенный, управляет временем жизни объекта|

---
#### Как работает?

- При копировании `shared_ptr` увеличивается внутренний счётчик.
    
- При уничтожении одного из владельцев счётчик уменьшается.
    
- Когда счётчик становится 0 — вызывается `delete` на управляемом объекте.
    
---
### Особенности и риски

- **Возможна циклическая ссылка**, приводящая к утечке памяти.
    
- Более тяжёлый по сравнению с `unique_ptr` из-за синхронизации счётчика.
    
- Поддерживает **кастомные делитеры**.
---
### Пример

```cpp
#include <memory>

struct Foo { int x; };

int main() {
    std::shared_ptr<Foo> p1 = std::make_shared<Foo>();
    std::shared_ptr<Foo> p2 = p1; // Копируем, теперь два владельца

    p1->x = 10;
    // Объект удалится, когда p1 и p2 будут уничтожены
}
```

---
#### `weak_ptr`

#### Что это?

- Слабый указатель, не владеет объектом.
    
- Используется для **безопасного наблюдения** за объектом, управляемым `shared_ptr`.
    
- Позволяет избежать **циклических ссылок**.
    
---
#### Ключевые свойства

|                   |                                                                                     |
| ----------------- | ----------------------------------------------------------------------------------- |
| Свойство          | Описание                                                                            |
| Владение          | **Не владеет** объектом                                                             |
| Копирование       | Разрешено                                                                           |
| Перемещение       | Разрешено                                                                           |
| Получение объекта | Через метод `.lock()`, возвращает `shared_ptr` или `nullptr`, если объект уничтожен |

---
#### Как использовать?

```cpp
std::shared_ptr<Foo> sp = std::make_shared<Foo>();
std::weak_ptr<Foo> wp = sp; // наблюдатель

if (auto p = wp.lock()) {
    // Безопасно используем p — объект ещё жив
} else {
    // Объект уже уничтожен
}
```

---
### Зачем?

- Предотвращает **утечки памяти из-за циклических ссылок** в сложных графах объектов.
- Позволяет проверить, жив ли объект без продления срока его жизни.
- Основная цель `std::weak_ptr` — **разорвать циклические зависимости (`shared_ptr` ↔ `shared_ptr`)**, которые вызывают **утечки памяти** даже при использовании `shared_ptr`.

---

### 💣 Что за циклические зависимости?


Представь два объекта A и B, каждый из которых содержит `std::shared_ptr` на другой:

```cpp
struct B; // forward

struct A {
    std::shared_ptr<B> b_ptr;
};

struct B {
    std::shared_ptr<A> a_ptr;
};
```

теперь создадим их так:

```cpp
std::shared_ptr<A> a = std::make_shared<A>();
std::shared_ptr<B> b = std::make_shared<B>();
a->b_ptr{b};
b->a_ptr{a};
```

У каждого `shared_ptr` счётчик ссылок `use_count == 1`, но оба ссылаются друг на друга.  
Когда `a` и `b` выходят из области видимости — они **не уничтожатся**, потому что ссылки друг на друга **не дают счётчику стать 0**. Это и есть **утечка**.


```cpp
struct B; // forward

struct A {
    std::shared_ptr<B> b_ptr;
};

struct B {
    std::weak_ptr<A> a_ptr; // 💡 теперь weak_ptr!
};
```

теперь всё ок:

- `a` владеет `b`, `a->b_ptr` — это `shared_ptr`.
    
- `b` НЕ владеет `a`, `b->a_ptr` — это `weak_ptr`.
    
И когда `a` и `b` выходят из области видимости, **всё уничтожается нормально**, без утечек.

еще пример:

```cpp
#include <iostream>
#include <memory>

struct MyClass {
    void say() { std::cout << "I'm alive\n"; }
};

int main() {
    std::shared_ptr<MyClass> sp = std::make_shared<MyClass>();
    std::weak_ptr<MyClass> wp = sp;  // 👈 создание weak_ptr

    if (auto locked = wp.lock()) {  // превращаем weak_ptr обратно в shared_ptr
        locked->say();
    } else {
        std::cout << "Object already destroyed\n";
    }

    sp.reset();  // уничтожаем объект

    if (auto locked = wp.lock()) {
        locked->say();
    } else {
        std::cout << "Object already destroyed\n";  // ← сюда попадём
    }
}

```


---
#### `auto_ptr` (устарел!)

#### Что это?

- Умный указатель из C++98/C++03 для уникального владения.
    
- Имел семантику **перемещения через копирование** (чуть ли не единственная форма перемещения до C++11).
    
- Ввел много проблем с безопасностью и предсказуемостью.
    
- Устарел, **не использовать!**
    
---
#### Почему устарел?

- Копирование `auto_ptr` **забирало владение у исходного объекта** — приводило к неожиданному поведению.
    
- Нет поддержки массивов.
    
- Заменён на `unique_ptr` в C++11.
    
---
#### Совет

> Не используй `auto_ptr`. Если работаешь с современным C++ — всегда используй `unique_ptr` или `shared_ptr`.

---

# Итог: когда что использовать?

|   |   |   |
|---|---|---|
|Тип указателя|Когда применять|Особенности|
|`unique_ptr`|Уникальное владение, один владелец|Легковесный, запрещено копирование|
|`shared_ptr`|Разделяемое владение, несколько владельцев|Управление сроком жизни через счётчик|
|`weak_ptr`|Наблюдение за объектом, без владения|Избегание циклов владения|
|`auto_ptr`|**Не использовать**|Устарел, заменён `unique_ptr`|
Предпочитаем использвание конструкции `make_unique` или `make_shared` для предотвращения повторной выделении памяти для `Class` и _control block_. В случае использования контрукций `make` память на объявление умного указателя выделяется *единожды*