
# инициализация_объекта_в_аргументах

Дата: [[2025-07-28]]
Теги: #cpp
Связи: [[c++]] 

---

**Описание**:

**Пример кода**:

```cpp
struct C{ C(int){}; ~C{} = default;};
void Kal(){};
void Foo(shared_ptr<C> shared_ptr, void(* Kal)()) { какие-то действия};
int main() {
    int speed = 5;
    F(shared_ptr<C>(new C(speed)), Kal); // плохо memory leak
    F(shared_ptr<C>(make_shared(speed)), Kal); //норм
}
```

Если `computePriority()` выбросит исключение, то `shared_ptr` **ещё не создан**, а память под `new C(speed)` **уже выделена**. → **утечка памяти**!

В C++ **порядок вычисления аргументов в вызове функции не определён** (до C++17 это был полный рандом, начиная с C++17 есть частичные гарантии, но не для всего).

То есть:

- Компилятор может сперва вычислить **первый аргумент** — `std::shared_ptr<C>(new C(speed))`,
    
- Или сперва вызвать `Kal()` (третий аргумент),
    
- Или в любом порядке.

## Где и когда может быть утечка?

### Сценарий 1 — `new C(speed)` выполняется, потом вызывается `Test()`, которая бросает

- `new C(speed)` выделил память.
    
- `shared_ptr` создан.
    
- `Test()` вызвана — бросает исключение.
    
- Конструктор `shared_ptr` завершился, временный объект существует.
    
- При выбросе исключения происходит разрушение временных объектов (в том числе временного `shared_ptr`),
    
- `shared_ptr` удалит объект `C`.
    
- **Утечки нет.**
    

### Сценарий 2 — `Test()` вызывается **первым**, и бросает исключение

- `Test()` выбрасывает исключение.
    
- `new C(speed)` и `shared_ptr` ещё **не созданы**.
    
- Выделения памяти под `C` нет, следовательно — утечки нет.

### Сценарий 3 

```cpp
Widget* p = new Widget;
int prio = computePriority();  // бросает исключение
auto sp = std::shared_ptr<Widget>(p); // сюда не дойдёт — утечка!
processWidget(sp, prio);
```
