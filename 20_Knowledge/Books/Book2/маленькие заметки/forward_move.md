
# forward_move

Дата: [[2025-07-28]]
Теги: #cpp
Связи: [[c++]] 

---

**Описание**:
Как мы знаем, `std::move` сам по себе ничего не пермещает, а `std::forward` ничего не передает. Зачем же они нужны?

- `std::move` приводит параметр к _rvalue_
- `std::forward` приводит параметр либо к _rvalue_, либо оставляет _lvalue_ в зависимости от переданного ему аргумента
#### Но как оно(тип параметра) там оказалось?
- Вы можете удивиться, откуда `std::forward` может знать, был ли ее аргумент инициа лизирован _rvalue_? Например, как в приведенном выше коде s t d : : forward может сказать, был ли param инициализирован с помощью _lvalue_ или _rvalue_? Краткий ответ заключается в том, что эта информация кодируется в параметре `Т` шаблона `Foo`. Этот пара метр передается `std::forward`, которая восстанавливает закодированную информацию.
**Пример кода**:

```cpp
include <memory.h>
#include <utility>

class Widget{
public:
  Widget() = default;
  ~Widget() = default;
  Widget(const Widget&) {};
  Widget(Widget&&) {};
};

void Ref(const Widget& w) {}; // copy param
void Ref(Widget&& w) {}; // move param

template<typename T> 

void Foo(T&& p) {
  Ref(p); //при любой из данных перегрузок в Ref() уйдет lvalue
  Ref(std::forward<T>(p)); // теперь будет деферсификация в записимости от переданного аргумента
}

int main() {
  Widget w;
  Foo(w); //lvalue - copy ctor
  Foo(std::move(w)); //rvalue - move ctor
  return 0;
}
```

### Резюме:
- Что еще более важно, так это то, что использование `std::move` выполняет безусловное приведение к _rvalue_, в то время как использование `std::forward` означает приведение к _rvalue_ только ссылок, связанных с _rvalue_. Это два совершенно различных действия.
- Первое из них обычно настраивает перемещение, в то время как второе просто передает объект другой функции способом, сохраняющим исходную характеристику объекта (_lvalue_ или _rvalue_). Поскольку эти действия совершенно различны, наличие двух разных функций (и разных имен функций) является преимуществом, позволяющим их различать.